\section{Finalized System Architecture}

The system architecture is a unified framework integrating physical hardware, a high-fidelity simulator, and a core application layer. This design enables seamless transition between real-world deployment and software-based testing. As shown in \ref{fig:crowdsync_architecture} the complete system consists of 3 main components,
\begin{enumerate}
\item \textbf{Hardware-Based Indoor Localization System:} This component represents the physical deployment layer responsible for real-time tracking.
\item \textbf{Simulation Environment:} A digital twin built to replicate the hardware system, allowing for development and validation without physical constraints.
\begin{itemize}
\item \textbf{Human Generator:} Simulates realistic crowd dynamics, creating random and complex movement paths to mimic human behavior.
\item \textbf{Localizer:} A software-based engine that models UWB signal propagation and executes the localization algorithms (TDoA) to output virtual tag coordinates.
\end{itemize}
\item \textbf{Core Application Logic:} The central processing application that drives the visual experience, agnostic to whether the input comes from hardware or simulation.
\begin{itemize}
\item \textbf{Pattern Generator:} A mathematical engine that creates complex, algorithmic visual effects and color waves based on spatial coordinates.
\item \textbf{Synchronizer:} The bridge module that maps the generated visual patterns to specific Tag IDs, transmitting the correct lighting commands to each user in real-time.
\end{itemize}
\end{enumerate}

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=0.9\textwidth]{progress_report_images/crowdsync_architecture.jpg}
    \caption{ CrowdSync High Level System Architecture.}
    \label{fig:crowdsync_architecture} % useful for referencing later
\end{figure}

\section{Hardware Localization Scheme}
The hardware Localization Scheme is primarily used for localizing the tags using Ultrawide band (UWB) technology. The physical layer of the localization system comprises three primary components such as Tags which are dynamic in movement, anchors fixed in known positions and a Gateway which collects ranging data from anchors and runs the localization engine to calculate the position of each tag.

\subsection{Anchor and Tag Design}
The Anchor nodes serve as the fixed reference points within the localization infrastructure. Each Anchor consists of a STM32 Microcontroller and interface with a UWB transceiver module.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/stm32_nucleo.png}
        \caption{\textbf{Microcontroller} STM32F446RET6 (Nucleo development board)}
        \label{fig:stm32_nucleo}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/dwm3000_shield.png}
        \caption{\textbf{UWB Module} DW3000 (DWM3000EVB Shield)}
        \label{fig:dwm3000_shield}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/anchor_top_pcb.png}
        \caption{\textbf{Top Shield} (Power Delivery + Communication Module)}
        \label{fig:anchor_top_pcb}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/anchor_with_tripod.png}
        \caption{\textbf{Final Anchor Setup with Tripod}}
        \label{fig:anchor_with_tripod}
    \end{subfigure}
    \caption{Anchor Design and Setup. The Anchor consists of a STM32 Nucleo development board interfaced with a DWM3000EVB Shield, which contains the DW3000 UWB transceiver. The top PCB shield is custom-designed to handle power delivery and communication interfaces. The complete Anchor setup is mounted on a tripod for optimal placement within the localization environment.}
    \label{fig:anchor_design} 
\end{figure}

The Tag Nodes are designed for mobility and energy efficiency. They feature a minimized form factor and sleep-mode logic to extend battery life. Unlike the anchors, the tags operate primarily in a responsive or strictly transmission-based state depending on the localization scheme employed (TWR or TDOA). The Tag nodes are also made using the same hardware as Anchor hardware with STM32 Microcontroller and UWB Transceiver but with a custom developed shield with leds and voltage regulators and the tag is battery powered.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/stm32_nucleo.png}
        \caption{\textbf{Microcontroller} STM32F446RET6 (Nucleo development board)}
        \label{fig:stm32_nucleo}
    \end{subfigure} 
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/dwm3000_shield.png}
        \caption{\textbf{UWB Module} DW3000 (DWM3000EVB Shield)}
        \label{fig:dwm3000_shield}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/tag_top_pcb.png}
        \caption{\textbf{Receiver and Lighting Module} (Power Delivery + Communication Module)}
        \label{fig:tag_top_pcb}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/tag_with_battery.png}
        \caption{\textbf{Final Tag Setup with Battery}}
        \label{fig:tag_with_battery}
    \end{subfigure}
    \caption{Tag Design and Setup. The Tag consists of a STM32 Nucleo development board interfaced with a DWM3000EVB Shield, which contains the DW3000 UWB transceiver. The top PCB shield is custom-designed consists of RF Module and voltage regulators. The complete Tag setup is powered by a battery for mobility and ease of deployment within the localization environment.}
    \label{fig:tag_design}
\end{figure}

\subsection{System Backbone and Gateway Integration}

The system employs a wired backbone to connect with the gateway. This wired backbone is primarily used for Data Aggregation, Wired Synchronization and Power Delivery. The Gateway, a Raspberry Pi 4  acts as the bridge between the localization network and the central processing server (pattern generator and the Synchronizer).

\subsubsection{Rationale for Wired RS-485 Backbone}

We selected the RS-485 standard for the communication backbone rather than a wireless mesh for the following reasons,
\begin{itemize}
    \item \textbf{Noise Immunity:} RS-485 utilizes differential signaling, which provides superior immunity to electromagnetic interference (EMI), a critical factor in crowded or industrial environments where Crowd Sync is deployed.
    \item \textbf{Cable Length and Topology:} It supports long-distance cabling (up to 1200m) in a daisy-chain as well as star topology\cite{rs_485_datasheet}. This will improve the scalability of the system.
    \item \textbf{Determinism:} A wired bus eliminates the nondeterministic packet loss and latency associated with wireless backhaul, ensuring that timestamp data reaches the solver reliably.
\end{itemize}

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=1.0\textwidth]{progress_report_images/wired_backbone.jpg}
    \caption{The anchor STM32 MCU's UART interface is connected to a TTL-to-RS-485 converter module. On the other end, an RS-485-to-USB converter is used and connected to the Raspberry Pi via its USB interface. In later stages, this connection will be migrated to the Raspberry Pi’s native USART interface to enhance scalability. A CAT-5e cable is used to interconnect the modules, as it provides reliable signal transmission over long distances and offers improved noise immunity due to its twisted-pair structure and shielding against electromagnetic interference}
    \label{fig:wired_backbone} % useful for referencing later
\end{figure}

\section{Localization Methods: Double-Sided Two-Way Ranging (DS-TWR)}
To mitigate the clock drift errors inherent in Single-Sided TWR, we implemented Double-Sided Two-Way Ranging (DS-TWR) as mentioned in\cite{2024_qorvo_us_inc_aps013_nodate}. This method involves three messages per ranging exchange, allowing the system to cancel out clock frequency offsets between the tag and the anchor.

\subsection{Methodology}
In standard Single Sided TWR the initiator transmits a radio message to the responder and records its time of transmission (transmit timestamp) $t_1$. The responder receives the message and transmits a response (a radio message) back to the initiator after a particular delay $t_{reply}$. The initiator then receives this response and records a receive timestamp $t_2$.

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=1.0\textwidth]{progress_report_images/ss_twr.png}
    \caption{High Level diagram on how messages are exchanged on standard Two Way Ranging}
    \label{fig:ss_twr} % useful for referencing later
\end{figure}

Now using the timestamps $t_1$ and $t_2$, the initiator can calculate the round trip time $t_{roundtrip}$ and knowing the reply time in the tag, $t_{reply}$, the TOF can be determined by by equation,

\begin{equation}
    t_{roundtrip} = t_2 - t_1
\end{equation}

\begin{equation}    
    t_{tof} = \frac{t_2 - t_1 - t_{reply}}{2}
\end{equation}

The Double Sided TWR (DS-TWR) reduces the error that happens due to clock and frequency drift\cite{an_alternative_double-sided_two_way_ranging_method_2016}.

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=1.0\textwidth]{progress_report_images/ds_twr.png}
    \caption{High Level diagram on how messages are exchanged on Double Sided Two Way Ranging}
    \label{fig:ds_twr} % useful for referencing later
\end{figure}

The Time of Flight $t_{tof}$ is calculated using the following expansion:
\begin{equation}    
    t_{tof} = \frac{t_{round1}*t_{round2} -t_{reply1}*t_{reply2}}{(t_{round1} + t_{round2} + t_{reply1} + t_{reply2})}
\end{equation}

Where $t_{round}$ represents the round-trip time measured by the initiator(Tag), and $t_{reply}$ represents the response delay measured by the responder(Anchor).

\subsection{Implementation Variants and Scalability Analysis}
We implemented and compared two variations of this protocol to assess network capacity.

\subsection{Tag-Initiated DS-TWR (Standard Approach)}
In this configuration, tags wake up and transmit a Poll message asynchronously. Each tag operates in a round-robin manner, where it performs ranging with the anchors in turn. Overall, this effectively operates as a random-access ALOHA protocol\cite{ridolfi_analysis_2018-1}.

\textbf{Limitation:} As tag density increases, the probability of packet collisions rises exponentially. Since there is no central coordination, multiple tags attempting to range simultaneously result in mutual interference and packet loss, severely limiting scalability.

\subsection{Anchor-Initiated DS-TWR (Optimized Approach)}
To address the collision bottlenecks, we inverted the control logic. The Anchor acts as the master coordinator for UWB network. This allows the system to schedule ranging events centrally. This includes following stages
\begin{enumerate}
    \item \textbf{Registration Phase:} When a tag first enters the network, it performs a brief registration handshake. The anchor adds this tag ID to a known registry.
    \item \textbf{Round-Robin Scheduling:} Once registered, the anchor iterates through its list of known tags, initiating ranging with each tag sequentially in a Round-Robin fashion.
\end{enumerate}

\textbf{Scalability Improvement:} By deterministically scheduling which tag communicates at any given millisecond, we eliminate RF collisions during the ranging phase. This centralized control ensures that airtime is utilized efficiently, allowing for a higher density of tags compared to the random-access nature of the tag-initiated approach. However, in both approaches, the localization frequency (frame rate) decreases as the number of tags increases.

\subsection{Analysis of Results and Filtering}
Raw distance measurements from DS-TWR are susceptible to noise from multipath propagation and Non-Line-of-Sight (NLOS) conditions. To enhance position accuracy, we tried out several filtering strategies,

\begin{enumerate}
    \item \textbf{Initial Noise Reduction (Linear Kalman Filter)}
    Initially, a standard 2D Linear Kalman Filter (LKF) was applied to the raw coordinates derived from trilateration. While this successfully smoothed high-frequency jitter, it struggled to track dynamic movement accurately, often introducing lag during rapid turns.
    \item \textbf{Extended Kalman Filter (EKF) with Constant Velocity Model}
    To address the dynamic limitations of the LKF, we transitioned to an Extended Kalman Filter (EKF) utilizing a Constant Velocity (CV) process model. This model assumes that the tag's velocity remains constant between short sampling intervals, with deviations modeled as a discrete time white noise model.
    The state vector $x_k$ is defined as,

    \begin{equation}
        x_k = \begin{bmatrix} p_x \\ p_y \\ v_x \\ v_y \end{bmatrix}
    \end{equation}

    The process noise is modeled as \textbf{discrete white noise acceleration (DWNA)}, allowing the filter to account for sudden changes in speed or direction as "acceleration noise" rather than measurement error.

    \begin{equation}
        Q = \sigma_a^2 \begin{bmatrix} \frac{\Delta t^4}{4} & 0 & \frac{\Delta t^3}{2} & 0 \\ 0 & \frac{\Delta t^4}{4} & 0 & \frac{\Delta t^3}{2} \\ \frac{\Delta t^3}{2} & 0 & \Delta t^2 & 0 \\ 0 & \frac{\Delta t^3}{2} & 0 & \Delta t^2 \end{bmatrix}
    \end{equation}

    This advanced filtering significantly reduced the Root Mean Square Error (RMSE) compared to raw trilateration, providing smoother trajectories even when individual ranging packets were lost or corrupted.

    To evaluate the efficacy of the filtering pipeline, a static test was conducted where the tag was placed at a fixed known coordinate for a duration of N = 256 samples. We compared the performance of the Raw Trilateration, Linear Kalman Filter (KF), and Extended Kalman Filter (EKF) using Root Mean Square Error (RMSE) and Standard Deviation (SD) as key performance metrics.
\begin{figure}[H]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/raw_x.png}
        \label{fig:raw_x}
    \end{subfigure}
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/kf_x.png}
        \label{fig:kf_x}
    \end{subfigure}
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/ekf_x.png}
        \label{fig:ekf_x}
    \end{subfigure}
    \caption{Time-series analysis of the X-coordinate estimation during static testing. The plot compares the raw trilateration output (gray) against the Linear Kalman Filter (green) and Extended Kalman Filter (blue), highlighting the noise reduction capability of the EKF.}
    \label{fig:static_test_x} % useful for referencing later
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/raw_y.png}
        \label{fig:raw_y}
    \end{subfigure}
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/kf_y.png}
        \label{fig:kf_y}
    \end{subfigure}
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=\linewidth]{progress_report_images/ekf_y.png}
        \label{fig:ekf_y}
    \end{subfigure}
    \caption{Time-series analysis of the Y-coordinate estimation. The EKF response demonstrates significant attenuation of high-frequency jitter compared to the raw signal and standard KF but stable over the time.}
    \label{fig:static_test_y} % useful for referencing later
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{progress_report_images/2d_scatter_raw_kf_ekf.png}
    \caption{2D Spatial Scatter plot of estimated positions relative to the ground truth. The dispersion of the raw data points (wide scatter) contrasts with the tight clustering of the EKF estimates, visually representing the improvement in precision.}
    \label{fig:static_test_2d} % useful for referencing later
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=0.6\linewidth]{progress_report_images/twr_2d_scatter_only.png}
\caption{Dynamic test data showing the trajectory of a moving tag over time. The raw trilateration points (gray) exhibit significant noise and outliers, while the EKF estimates (blue) form a coherent path that closely follows the expected movement pattern, demonstrating the filter's ability to maintain stability in dynamic conditions.}
\label{fig:dynamic_test_2d} % useful for referencing later
\end{figure}

\end{enumerate}

\begin{table}[H]
    \centering
    \renewcommand{\arraystretch}{1.6} % better row spacing
    \begin{tabular}{|p{2.6cm}|p{3.0cm}|p{3.0cm}|p{3.5cm}|}
        \hline
        \textbf{Method} & \textbf{RMSE (m)} & \textbf{Mean (m)} & \textbf{Std Deviation (m)} \\
        \hline
        \textbf{Raw} & 0.3046 & 0.2999 & 0.0533 \\
        \hline
       \textbf{KF} & 0.3027 & 0.3008 & 0.037 \\
        \hline
       \textbf{EKF} & 0.3911 & 0.3901 & 0.0272 \\
        \hline
    \end{tabular}
    \caption{Performance Metrics for Static Localization Test.}
    \label{tab:static_test_metrics} % useful for referencing later
\end{table}

The static test data highlights a critical trade-off between absolute accuracy and signal stability.
\begin{itemize}
    \item \textbf{Precision and Stability:} The Extended Kalman Filter (EKF) demonstrated superior noise suppression, reducing the Standard Deviation by approximately 50\% (from 0.0533m to 0.0272m). 
    \item \textbf{Accuracy and Bias:} While the EKF shows an increase in RMSE (0.3046 m) compared to the raw input (0.3911 m), this discrepancy is attributed to the filter converging on a systematic bias rather than random error.
\end{itemize}

\textbf{Conclusion:} The implementation prioritizes precision over absolute accuracy. Although the EKF does not correct the mean calibration offset, it successfully transforms a noisy, fluctuating signal into a smooth, coherent trajectory, significantly improving the system's stability.

\section{Localization Methods: Time Difference of Arrival (TDOA)}
To achieve the massive scalability required for the full CrowdSync deployment, we transitioned to a Time Difference of Arrival (TDOA) scheme. In this architecture, tags broadcast a single ''blink'' message. Multiple anchors receive this message, and the position is calculated based on the difference in arrival times.

\subsection{The Challenge of Time Synchronization: The Need for a Single Time Domain}
For TDoA to function, all anchors must operate within a unified time domain. Mathematically, the TDoA equation assumes that $T_{Rx,A}$ and  $T_{Rx,B}$ are measured against the exact same reference zero. If Anchor A's clock is even slightly ahead of Anchor B's, the resulting time difference will be skewed, translating directly into a position error. In UWB systems, where signals travel at the speed of light $C\approx30 cm/ns$, a synchronization error of just 1 nanosecond results in a 30 cm positioning error.

\subsubsection{Clock Drift and Offset}
Even if two anchors are powered on at the exact same instant, their internal clocks will immediately begin to diverge. This is due to two primary factors:
\begin{itemize}
    \item \textbf{Initial Offset:} No two startup sequences are identical. One oscillator may stabilize a few microseconds faster than another, creating a constant time bias from $t=0$.
    \item \textbf{Clock Drift:} The crystal oscillators (XTALs) that drive these clocks are physical components subject to manufacturing tolerances, temperature variations, and voltage fluctuations. A "10 MHz" crystal might actually oscillate at 10.00001 MHz on Anchor A and 9.99999 MHz on Anchor B. Over time, these minute frequency differences accumulate, causing the time count on each anchor to drift apart linearly or non-linearly.
\end{itemize}

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/clock_drift_plot.png}
    \caption{Analysis of non-linear clock drift between two anchor nodes}
    \label{fig:clock_drift_analysis} % useful for referencing later
\end{figure}

Figure \ref{fig:clock_drift_analysis} shows that clock drift between two anchors that start synchronously (at the same time)  while the tag remains stationary. Over time, the differences between the difference of the received raw timestamps(red line) for the same sequence number is not constant and does not vary linearly. Instead, it exhibits nonlinear behavior due to clock drift caused by frequency mismatch and instability in the anchors’ crystal oscillators.

\subsection{The Ideal (but Impractical) Solution}
The theoretically perfect solution would be to drive all anchors using a single, high-precision external oscillator connected via cables. This would ensure that every clock tick happens simultaneously across the entire network. However, this is highly impractical for real-world deployments due to the cost, complexity, and signal degradation associated with running high-frequency clock lines over long distances.

\subsection{Practical Synchronization Methodology}
Since a single physical clock is impractical, the standard industry approach is to model the relationship between the separate clocks mathematically. This involves designating a "Master Clock" (reference time) and periodically correlating the "Slave Clocks" to it.

\subsection{The Master-Slave Sync Model}
A Master Anchor broadcasts a synchronization pulse (either wired or wireless) at fixed intervals (e.g. every 100ms).

\begin{enumerate}
    \item \textbf{Reference Event:} The Master sends a pulse at global time $T_{Global}$.
    \item \textbf{Local Capture:} Each Slave receives this pulse and records its local timestamp $T_{Local}$.
    \item \textbf{Offset and Drift Calculation:} By comparing the sequence of $(T_{Global}, T_{Local})$ pairs over time, we can estimate the offset and drift between the Master and Slave clocks.
\end{enumerate}

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=0.7\textwidth]{progress_report_images/master_slave_Sync_model.png}
    \caption{Master-Slave-Time-Synchronization-Model, where a reference Master Anchor sends periodic synchronization pulses to Slave Anchors. The Slave Anchors capture the local timestamps of these pulses, allowing the gateway to calculate clock offset and drift over time.}
    \label{fig:master_slave_sync_model} % useful for referencing later
\end{figure}

\subsection{Method 1 Linear Regression (Statistical Smoothing)}
This method is designed to mitigate high-frequency noise (jitter) in the synchronization signal, common in wired trigger setups. The system maintains a sliding window of the last N synchronization pairs. We fit a linear equation $y = mx + c$ to these points using the Least Squares method, where $y$ is Global Time and $x$ is Local Time.

\begin{itemize}
    \item \textbf{Slope m:} Represents the relative frequency difference (clock drift rate) between the Master and Slave crystals.
    \item \textbf{Intercept c:} Represents the time offset at $t = 0$.
\end{itemize}

Prediction: When a Tag Blink arrives at local time $T_{Tag,Local}$, the corrected time is calculated as:
\begin{equation}
    T_{Tag,Global} = m * T_{Tag,Local} + c
\end{equation}

This method acts as a low-pass filter. It is excellent for smoothing out the "jittery" edges of a wired sync pulse. However, it creates "inertia," meaning the system reacts slowly to sudden changes in crystal frequency (e.g., caused by rapid temperature shifts).

\subsection{Method 2: Extrapolation (Instantaneous Correction)}
This method, derived from the ATLAS system\cite{tiemann_atlas_2016} architecture, assumes the synchronization timestamps are precise but the clock drift is continuous. It uses only the most recent synchronization interval to calculate parameters.
The model calculates the instantaneous clock skew based on the difference between the current sync pulse $k$ and the previous sync pulse $k-1$.

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=1.0\textwidth]{progress_report_images/extrapolation_time_sync.png}
    \caption{Extrapolation Time Synchronization Model, illustrating how the system predicts the global time of a tag blink based on the most recent synchronization data.}
    \label{fig:extrapolation_time_sync} % useful for referencing later
\end{figure}

Equations from ATLAS\cite{tiemann_atlas_2016}:
\begin{enumerate}
    \item \textbf{Offset Calculation ($\epsilon_{n,k}$):} The difference between the ideal sync arrival time ($t_{r,k}$) and the measured local time ($t_{Sn,k}$):
    \begin{equation}
        \epsilon_{n,k} = t_{Sn,k} - t_{r,k}
    \end{equation}

    \item \textbf{Drift/Skew Estimation ($\dot{\epsilon}_{n,k}$):} The rate of change of the offset over the sync interval ($\tau_s$):
    \begin{equation}
        \dot{\epsilon}_{n,k} = \frac{\epsilon_{n,k} - \epsilon_{n,k-1}}{\tau_s}
    \end{equation}

    \item \textbf{Tag Time Correction:} When a tag frame arrives at local time $t_{n,i}$, the offset is extrapolated:
    \begin{equation}
        \epsilon_{n,i} = \epsilon_{n,k} + \dot{\epsilon}_{n,k} \cdot (t_{n,i} - t_{Sn,k})
    \end{equation}

    \item \textbf{Final Global Time:}
    \begin{equation}
        t_{n,i}^{corrected} = t_{n,i} - \epsilon_{n,i}
    \end{equation}

    \item \textbf{Wireless Adaptation:} For the wireless implementation, the Offset $\epsilon$ was further adjusted to subtract the \textbf{Time-of-Flight (ToF)} of the synchronization packet, ensuring the Slave clock is aligned with the Master's transmission time, not its arrival time.
    \begin{equation}
        Distance_{Master \rightarrow Slave} / c
    \end{equation}

\end{enumerate}

\subsection{Experimental Setup and Results for TDOA}
To validate synchronization, we placed a tag at the exact geometric center between two anchors. Ideally, the Time Difference of Arrival ($\delta{t}$) should be zero. Any deviation from zero represents the synchronization error + measurement noise.

\begin{figure}[H] % [H] = force "here" placement (from the float package)
    \centering
    \includegraphics[width=0.7\textwidth]{progress_report_images/static_test_middle.jpg}
    \caption{TDOA Clock Synchronization Test Setup for Two Anchors and a stationary Tag in the exact middle between the anchors}
    \label{fig:tdoa_test_setup_middle} % useful for referencing later
\end{figure}

\subsubsection{Wired Synchronization Results (Using Method 1)}
\begin{itemize}
    \item \textbf{Implementation}
        Wired GPIO triggers from raspberry pi using Linear Regression (N = 10). Observation: The wired signal had significant edge jitter ($\approx{100-500ns}$) and unknown phase shifts.
    \item \textbf{Outcome}
        Method 1 (Regression) stabilized the readings, but the resulting position data still exhibited a "wandering baseline" error and overtime shifts to different values due to the physical limitations of the wire capacitance.
        \begin{figure}[H] % [H] = force "here" placement (from the float package)
            \centering
            \includegraphics[width=0.9\textwidth]{progress_report_images/wired_drift_plot.png}
            \caption{Uneven Distance Shifts Caused by Wired Anchor Synchronization Imperfections}
            \label{fig:wired_drift_plot} % useful for referencing later
        \end{figure}
        The figure \ref{fig:wired_drift_plot} shows the behavior when using the wired synchronization method. The distance differences are calculated from the timestamp differences of tag blink receptions at Anchor A and Anchor B, multiplied by the speed of light. Even after applying basic outlier rejection and a basic Kalman filter, the results exhibit uneven shifts. Ideally, the expected plot should be a straight line with acceptable noise and a constant offset. The observed phase shifts are likely caused by errors introduced by the wired synchronization setup, including physical and electrical differences in the synchronization cables, as well as variations due to environmental or connection changes.
\end{itemize}

\subsubsection{Wireless Synchronization Results (Using Method 2)}
\begin{itemize}
    \item \textbf{Implementation}
        Periodic UWB broadcasts (10Hz) using the ATLAS\cite{tiemann_atlas_2016} Extrapolation method. The DW3000's $dwt\_setdelayedtrxtime$ feature ensured packet transmission with sub-nanosecond precision.
    \item \textbf{Outcome}
        Because the input data was precise, Method 2 performed superiorly. It correctly tracked the crystal drift ($\approx{10 ppm}$) without the lag associated with regression.
    \item \textbf{Precision:}
        The raw, unfiltered data exhibits a standard deviation of $\sigma = 7.4cm$. This low variance indicates that the wireless synchronization logic is successfully maintaining sub-nanosecond coherence between anchor clocks, effectively mitigating the random jitter often associated with wireless packet exchange.
    \item \textbf{Offset Analysis:}
        A consistent mean offset of approximately $-5.1 meters$ is observed in the data. This systematic error is attributed to the geometric placement of the Master Anchor, which was not equidistant from the Slave Anchors during this specific test setup. However, the constancy of this offset confirms that the synchronization lock is stable and does not drift over time.
        \begin{figure}[H] % [H] = force "here" placement (from the float package)
            \centering
            \includegraphics[width=0.9\textwidth]{progress_report_images/wireless_drift_plot.png}
            \caption{Comparative analysis of wireless  synchronization stability using midpoint tag validation. The plot displays the raw TDOA measurements, demonstrating a high degree of stability ($\sigma = 7.4cm$), despite a constant geometric offset ($-5.1m$) due to Master Anchor placement offset.}
            \label{fig:wireless_drift_plot} % useful for referencing later
        \end{figure}
\end{itemize}

\subsubsection{Conclusion}
The experimental results demonstrate that for any synchronization methodology whether wired or wireless to be successful, two critical conditions must be strictly met:
\begin{enumerate}
    \item \textbf{Precision of the Master Clock Sync Events: } The Master Clock must generate synchronization signals with absolute periodicity. This was proven in the wireless experiment, where utilizing the DW3000's hardware-based dwtsetdelayedtrxtime feature eliminated software-induced jitter. By triggering transmissions based on the exact tick count of the internal system clock rather than CPU processing loops, timing inconsistencies were effectively removed.
    \item \textbf{Consistency of the Transmission Medium} The medium through which the synchronization signal travels must be identical and predictable for all slave nodes.
    \begin{itemize}
        \item \textbf{Wired Limitations:} In the wired experiments, physical discrepancies such as mismatched cable lengths, varying impedance, and signal noise introduced significant phase shifts and edge jitter. These hardware imperfections caused the "wandering offset" observed in the data, limiting the achievable accuracy.
        \item \textbf{Wireless Superiority:} The wireless mechanism proved superior in this regard. In \textbf{Line-of-Sight (LoS)} conditions, the UWB signal travels at the constant speed of light C in a predictable manner for all anchors. By mathematically accounting for the Time-of-Flight (ToF), the wireless approach bypassed the physical inconsistencies of cabling, resulting in a significantly more stable and accurate synchronization grid.
    \end{itemize}
\end{enumerate}

\section{Core Application Logic}

\subsection{Human Generator (Simulation)} 
This is a \textbf{‘high-performance crowd simulation engine’} that generates and updates the positions of simulated humans within a venue. It models random Brownian-like motion with damping. 

To achieve high performance, \textbf{OpenMP (Open Multi-Processing)} is utilized in the generator code to instruct the compiler to distribute loop iterations across multiple CPU cores. This is implemented using the \texttt{\#pragma omp parallel for} directive. Each core executes its assigned chunk of the loop simultaneously, drastically reducing the total time taken.

\textbf{SIMD (Single Instruction, Multiple Data)}, which is a hardware-level acceleration technique that allows a single CPU instruction to operate on an entire "vector" of data simultaneously, is also used to further boost efficiency by allowing a single CPU instruction to process multiple data points at once. 

In contrast, SIMD allows the processor to pack multiple values into specialized, wide registers. \textbf{SoA (Structure of Arrays)} layout rather than the more common \textbf{AoS (Array of Structures)} is the critical data layout prerequisite that enables SIMD to work efficiently. Because x-coordinate values are being contiguous in memory (with SoA layout), by utilizing 256-bit \textbf{AVX2 (Advanced Vector Extensions)} registers, the system can process four 64-bit double-precision values in a single clock cycle. To make this work optimally, memory is aligned using \texttt{alignas(32)}, ensuring the data is perfectly positioned for the CPU to "grab" it at maximum speed. 

When combined, OpenMP provides multi-core scaling and SIMD provides instruction-level speed, resulting in a \textbf{"force multiplier"} effect that maximizes the total throughput of the generator.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{progress_report_images/human_gen_delay.png}
    \caption{Human generation delay per a frame is less than 0.5 ms}
    \label{fig:human_gen_delay}
\end{figure}

\subsection{Localization Estimator}
This is the mathematical "engine" that bridges the gap between the perfect simulation world and messy real-world physics. It takes the \textbf{True Positions} of humans from the Human Generator and converts them into \textbf{Estimated Positions} by simulating the behavior of Ultra-Wideband (UWB) sensors.

The process ensures the simulation is not "too perfect," adding the natural inaccuracies found in wireless localization systems. The estimation happens in two distinct mathematical stages:

\begin{enumerate}
    \item \textbf{Simulating the Signal}: In this first phase, the system mimics how UWB anchors at the venue corners would "hear" a tag carried by a human. For each human, the system calculates the exact distance to four fixed anchors (placed at the venue corners) and determines how long a signal would take to travel that distance. To make it realistic, this component adds \textbf{Gaussian Noise} to these times. This represents real-world interference, such as signal bouncing (multipath) or atmospheric conditions, that makes measurements slightly "fuzzy." 
    
    \item \textbf{Solving the Position}: In this second phase, once the system has these noisy "arrival times," it works backward to figure out where the human is. It uses a \textbf{Gauss-Newton (GN) Solver}. Finding a position based on time differences is a non-linear problem. As the solution, the GN solver starts with an "initial guess" and iteratively refines it. It adjusts the $(x, y)$ coordinates until the calculated distances to the anchors best match the noisy timing data it received.
\end{enumerate}

\subsection{Pattern Generator}
To achieve infinite visual variety without the heavy memory footprint of traditional textures, the system utilizes a procedural generation pipeline. Instead of loading static image files, it calculates colors mathematically in real-time. The system is composed of three primary pillars:

\begin{enumerate}
    \item \textbf{Pattern Configurations}: A centralized configuration file that stores the mathematical data of each pattern. It defines specific parameters such as frequency, amplitude, and scale.
    \item \textbf{Pattern Generator Class}: The "engine" of the component. This class contains the core logic that evaluates coordinates $(x, y)$ and time $(t)$ through mathematical functions. It transforms these raw inputs into dynamic, high-fidelity color states on the fly.
    \item \textbf{Pattern Selection Component}: The user-facing interface that allows for seamless switching between different algorithms at runtime. This allows users to instantly observe how different mathematical models affect the simulation’s visual output.
\end{enumerate}

By calculating colors "on the fly" according to the user's runtime choices, the system provides key advantages such as \textbf{Memory Efficiency}, \textbf{Resolution Independence}, and \textbf{Temporal Smoothness} so the patterns exhibit fluid, organic animations that never repeat or "loop" in a noticeable way.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/star_pattern_generated.png}
    \caption{Generated example Star Pattern using the mathematical function at time ‘t’}
    \label{fig:pattern_star}
\end{figure}

\subsection{Synchronizer} 
Acts as the critical link between the human's position data and the final visual output. It serves as a "translator" that converts spatial data (where a human is) into aesthetic data (what color that human should be). 

The primary workhorse of this component is the \texttt{update()} method. Its job is to take a snapshot of the current states and map them to the procedural pattern. The Synchronizer queries the \texttt{PatternGenerator} for what color each human should be at that position and time. It packages these results into a \texttt{HumanColorState}, creating a ready-to-use list for the renderer. The Synchronizer is modular; it only cares about the relationship between position and color. It uses almost no extra memory by "pointing" to existing pattern logic. Because it returns a \texttt{const\&} (constant reference), it guarantees that the visual data cannot be accidentally altered, ensuring \textbf{"data integrity"} across the pipeline.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/star_pattern_visualizer.png}
    \caption{Synchronizer output for the Star pattern snapshot at time ‘t’}
    \label{fig:sync_output}
\end{figure}

\subsection{Visualizer} 
This is a high-performance rendering engine built on \textbf{SFML (Simple and Fast Multimedia Library)} that transforms abstract data positions into a fluid crowd simulation display. To handle thousands of humans at high frame rates, the Visualizer uses a sophisticated \textbf{Two-Phase approach} to solve the bottleneck of preparing and drawing data sequentially on a single thread.

\begin{itemize}
    \item \textbf{Phase 1}: The SFML engine receives high-precision coordinates. Using \textbf{OpenMP}, the workload is parallelized across all available CPU cores. Each core processes a distinct subset of humans, performing coordinate transformation and styling pre-allocated shapes. Since each core operates on a unique \texttt{humanShape} index, there is no memory contention.
    \item \textbf{Phase 2}: Sequential Drawing of the "Final Output". Since SFML’s \texttt{window.draw()} command is not thread-safe, this phase runs on a single thread, pushing the already-prepared shapes to the screen. 
\end{itemize}

Instead of creating and destroying objects every frame, the Visualizer maintains a \texttt{vector} of \texttt{CircleShape} in memory, updating properties as needed for maximum efficiency.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/visualizer_snapshot.png}
    \caption{Snapshot of the visualizer with 10,000 human positions}
    \label{fig:visualizer_snapshot}
\end{figure}

\subsection{Database \& Pattern Player}  
The Recording \& Playback System uses a \textbf{Hybrid Storage Architecture}. Instead of a single database, it splits the data to handle 10,000+ humans efficiently.

\begin{enumerate}
    \item \textbf{SQLite for organization}: Acts as the Librarian. It stores "metadata" like simulation date and an index of every frame, knowing exactly where each frame starts in the binary file.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/database_snapshot.png}
    \caption{SQLite database snapshot used to store offsets of the binary file and metadata}
    \label{fig:sqlite_snap}
\end{figure}

    \item \textbf{Binary Files for raw speed}: Acts as the Warehouse. It stores the raw "Human State" (position and color) in a compressed, 15-byte packet. 
\end{enumerate}

To record 10,000 humans at 30 FPS, the required memory write rate is:
\[ 10,000 \text{ humans} \times 15 \text{ bytes} \times 30 \text{ FPS} \approx 4.5 \text{ MB/s} \]

For a standard SSD (approx. 500 MB/s), this uses only about 1\% of the write bandwidth. 

Also, to ensure the simulation stays at a smooth 30 FPS, the system never waits for the hard drive to finish writing. The system uses a \textbf{Background Worker Thread} (Producer-Consumer model). 

\begin{enumerate}
    \item The Main Thread (Producer) packages data into a \textbf{Thread-Safe Queue} 
    \item The Worker Thread (Consumer) writes to disk without blocking the simulation.
\end{enumerate}

The playback engine is built for instant navigation. Because every frame has a fixed size and its location is indexed in SQLite, the system can perform \textbf{O(1) Random Access} (No Scanning). If the user moves the playback slider to the middle of a 2-hour recording, the system doesn't "fast-forward" through the file. It queries SQLite for the bin offset, "jumps" directly to that byte in the binary file, and reads the frame instantly. 
\section{RGB LED Data Reception and Control}

After processing in the synchronizer, the corresponding tag ID and color information are transmitted to the Gateway, which forwards the data to the wearable tags via the 2.4GHz transmitter. This unit is responsible for receiving the color data from the Gateway and driving the lighting system on each tag.

\subsection{Wireless Color Data Transmission Architecture}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/gateway-tag_transmission.png}
    \caption{Transmission between Gateway and Tag}
    \label{fig:gw_tag_transmission}
\end{figure}

\subsubsection{Gateway-to-Tag Communication Protocol}
Wireless reception and transmission are handled by a \textbf{2.4 GHz NRF24L01} module. Addressable LEDs \textbf{WS2812B} are used for emitting the light. The received packet contains the \textbf{\texttt{Tag\_ID} and the assigned color value}. Upon successful reception and validation of the \texttt{Tag\_ID}, the color data is applied to the \textbf{LEDs integrated on the tag}, enabling real-time visual identification.

\subsubsection{NRF24L01 Configuration and RF Channel Allocation}
The wireless communication between the Gateway and the wearable tags is implemented using the \textbf{NRF24L01 2.4 GHz transceiver module} \cite{nordic_semiconductor_asa_nrf24l01_nodate}. This module operates in the \textbf{2.4–2.5 GHz ISM band} and supports configurable data rates of \textbf{250 kbps, 1 Mbps, and 2 Mbps}, enabling low-latency and reliable communication.

Each NRF24L01 module supports \textbf{125 selectable RF channels}, allowing multiple independent wireless networks to coexist in the same environment. Additionally, each channel supports up to \textbf{six logical addresses (pipes)}, enabling communication with multiple devices simultaneously. In this system, a unique \texttt{Tag\_ID} is used to ensure that only the intended tag responds to the received color data.

\subsubsection{Packet Structure and Tag Identification Mechanism}
The NRF24L01 communicates with the controller using the \textbf{SPI protocol}, while the CE and CSN pins are used to control transmission and reception modes. Payloads of up to \textbf{32 bytes} can be transmitted in a single packet, which is sufficient for sending compact data such as \texttt{Tag\_ID} and RGB color values.

\subsubsection{Power Optimization and Transmission Range Analysis}
To optimize power consumption and communication reliability, the \textbf{Power Amplifier (PA)} level is configured based on the required operating range. Lower PA levels are used during short-range operation to reduce power usage, while higher levels can be enabled for extended range when necessary. In open-space conditions, the communication range can reach up to \textbf{25 m}, and even higher when PA/LNA variants with external antennas are used.

The NRF24L01 operates at \textbf{3.3 V}, with a typical transmission current of approximately \textbf{12 mA}. Due to its sensitivity to power supply noise, \textbf{local decoupling capacitors (10 µF–100 µF)} are placed close to the module’s VCC and GND pins to ensure stable operation. In the final tag design, power is derived from a \textbf{7.4 V Li-ion battery pack} and regulated on-board to meet the module’s voltage requirements.

Upon receiving a valid packet containing the matching \texttt{Tag\_ID} and color information, the tag controller decodes the data and updates the \textbf{LED color output in real time}, providing immediate visual feedback for identification and tracking purposes.

\subsubsection{Multi-Channel Round Robin Transmission Strategy}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/color_data_tx_channels.png}
    \caption{Color Data transmission channels}
    \label{fig:transmission_channels}
\end{figure}

Transmission of color data is transmitted via 5 channels. They were sent in a round robin manner to the tags where each transmission took 16ms for transmission. So the entire cycle takes 80ms to transmit.

\subsection{Receiver Circuit}

\subsubsection{Receiver Block Diagram Overview}
The receiver circuit consists of 4 key blocks:
\begin{itemize}
    \item Microcontroller
    \item NRF24L01 Transceiver
    \item Addressable LEDs
    \item Power regulation
\end{itemize}

The tag receiver unit is designed using the following block diagram.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/tag_receiver_diagram.png}
    \caption{Block Diagram of Tag receiver circuit}
    \label{fig:receiver_block_diagram}
\end{figure}

\subsubsection{Power Regulation}
As the microcontroller, we used an \textbf{ESP32}. Both MCU and Transceiver modules are operating at 3.3V and LEDs are powering at 5V. So we used 2 voltage regulators to regulate the voltage levels, and coupling capacitors are used to stabilise the voltage.

\subsubsection{PCB Design, Fabrication, and Hardware Implementation}
The schematic diagram and PCB layout of the tag receiver module are shown below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/tag_receiver_schematic.png}
    \caption{TDOA Schematic Diagram of the tag receiver circuit}
    \label{fig:tag_schematic}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{progress_report_images/tag_receiver_layout.png}
    \caption{Layout diagram of tag receiver circuit}
    \label{fig:tag_layout}
\end{figure}

Power is supplied by an \textbf{external 7.4 V Li-ion battery pack}, which is regulated on-board to meet the operating voltage requirements of the NRF24L01 module and the LED circuitry. After fabrication, the finalized PCB appears as shown below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{progress_report_images/tag_receiver_manufactured.png}
    \caption{TDOA Manufactured Tag receiver Printed Circuit Board}
    \label{fig:manufactured_pcb}
\end{figure}

A total of \textbf{five tag receiver boards} were fabricated for testing and validation purposes. In the completed tag assembly, this receiver PCB is \textbf{stacked with the UWB module and STM32}, enabling both \textbf{localization and color reception} functionalities within a single wearable unit.

\subsection{Controlling LEDs}

\subsubsection{WS2812B LED Architecture and Daisy-Chain Configuration}
The LEDs used are RGB WS2812B LEDs where they are connected in a \textbf{daisy chain} method. The DOUTs of LEDs are connected with DINs \cite{worldsemi_co_ltd_ws2812b_nodate}.  

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/led_daisy_chain.png}
    \caption{LEDs Connected as a Daisy Chain}
    \label{fig:led_daisy_chain}
\end{figure}

\subsubsection{Timing Requirements for Data Transmission}
In order to transmit a bit we need to follow the following steps:

\begin{itemize}
    \item \textbf{Transmitting a 1}:
    \begin{itemize}
        \item Time for the signal to remain high ($T1H$): 0.8 $\mu$s
        \item Time for the signal to remain low ($T1L$): 0.45 $\mu$s
    \end{itemize}
    \item \textbf{Transmitting a 0}:
    \begin{itemize}
        \item Time for the signal to remain high ($T0H$): 0.4 $\mu$s
        \item Time for the signal to remain low ($T0L$): 0.85 $\mu$s
    \end{itemize}
    \item \textbf{Latching the data}: After sending all the bits corresponding to the intensity values of all the LEDs that we want to control, we need to simply hold the value of the pulse wave at its minimum value for at least 50 $\mu$s.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{progress_report_images/led_timing_diagram.png}
    \caption{LEDs Control Timing Diagrams}
    \label{fig:led_timing}
\end{figure}

\subsubsection{Bit Encoding and Color Data Formatting (24-bit GRB Protocol)}
The signal needed for 1 LED is 24 bits, where 8 bits each are allocated for color Green, Red, and Blue. So for controlling 8 LEDs we need to send $24 \times 8 = 192$ bits in sequence and Save by Latch command. Figure \ref{fig:led_bit_sequence} shows the bit sequence diagram for controlling 8 LEDs.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{progress_report_images/led_bit_sequence.png}
    \caption{LEDs Bit Sequence Diagram}
    \label{fig:led_bit_sequence}
\end{figure}

\subsubsection{Conclusion}
The color data coming from the synchronizer is successfully transmitted to tags and lights up the color successfully.